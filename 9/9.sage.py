

# This file was *autogenerated* from the file 9/9.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_1p0 = RealNumber('1.0'); _sage_const_2 = Integer(2); _sage_const_7 = Integer(7); _sage_const_0 = Integer(0); _sage_const_1024 = Integer(1024); _sage_const_0p5 = RealNumber('0.5')# Partial d exposure attack
from sage.all import *
from Crypto.Util.number import *
from tqdm import tqdm
import itertools

with open("9/output.txt", "r") as f:
    n = Integer(int(f.readline().split(" = ")[_sage_const_1 ]))
    e = Integer(int(f.readline().split(" = ")[_sage_const_1 ]))
    c = Integer(int(f.readline().split(" = ")[_sage_const_1 ]))
    leak = Integer(int(f.readline().split(" = ")[_sage_const_1 ]))

def small_roots(f, X, beta=_sage_const_1p0 , m=None):
    N = f.parent().characteristic()
    delta = f.degree()
    if m is None:
        epsilon = RR(beta**_sage_const_2 /f.degree() - log(_sage_const_2 *X, N))
        m = max(beta**_sage_const_2 /(delta * epsilon), _sage_const_7 *beta/delta).ceil()
    t = int((delta*m*(_sage_const_1 /beta - _sage_const_1 )).floor())
    
    f = f.monic().change_ring(ZZ)
    P,(x,) = f.parent().objgens()
    g  = [x**j * N**(m-i) * f**i for i in range(m) for j in range(delta)]
    g.extend([x**i * f**m for i in range(t)]) 
    B = Matrix(ZZ, len(g), delta*m + max(delta,t))

    for i in range(B.nrows()):
        for j in range(g[i].degree()+_sage_const_1 ):
            B[i,j] = g[i][j]*X**j

    B =  B.LLL()
    f = sum([ZZ(B[_sage_const_0 ,i]//X**i)*x**i for i in range(B.ncols())])
    roots = set([f.base_ring()(r) for r,m in f.roots() if abs(r) <= X])
    return [root for root in roots if N.gcd(ZZ(f(root))) >= N**beta]
"""
Let t = number of bits of d_low
We have: 
    d * e = k * phi(n) + 1 = k * (n - p - q + 1) + 1
=>  leak * e = k * (n - p - q + 1) + 1 (mod 2^t)
=>  p * leak * e = k * (n * p - p^2 - n + p) + p (mod 2^t)
Because e is small enough, so we can bruteforce k and solve quadratic equation to get lsb of p
"""

t = (int(leak)).bit_length()
for k in tqdm(range(_sage_const_1 , e)):
    P = PolynomialRing(Zp(_sage_const_2 , t), 'x')
    x = P.gen()
    f = k * (n * x - x**_sage_const_2  - n + x) + x - x * leak * e
    for p_low, _ in f.roots():
        p_low = ZZ(p_low)
        p_hi = PolynomialRing(Zmod(n), 'p_hi').gen()
        p = p_hi * _sage_const_2 **t + p_low
        ans = small_roots(p.monic(), X=_sage_const_2 **(_sage_const_1024  - t), beta = _sage_const_0p5 )
        if ans == []:
            continue
        p = int(p(ans[_sage_const_0 ]))
        q = n // p
        assert p * q == n
        d = pow(e, -_sage_const_1 , (p - _sage_const_1 ) * (q - _sage_const_1 ))
        m = pow(c, d, n)
        try:
            print((long_to_bytes(m)).decode())
        except UnicodeDecodeError:
            continue

